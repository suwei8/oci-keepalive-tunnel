name: Monitor Resource Usage (ARM64)

on:
  schedule:
    # æ¯å¤© UTC 0ç‚¹ (åŒ—äº¬æ—¶é—´ 8:00) è¿è¡Œä¸€æ¬¡
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      target_host:
        description: 'æŒ‡å®šä¸»æœº (ç•™ç©º=å…¨éƒ¨)'
        required: false
        default: ''

jobs:
  monitor-loop:
    name: "Resource Monitor"
    runs-on: ubuntu-latest
    timeout-minutes: 120  # å‡è®¾æœ‰20å°ä¸»æœºï¼Œæ¯å°5åˆ†é’Ÿï¼Œä¸²è¡Œä¼šå¯¼è‡´è¶…æ—¶ã€‚éœ€è¦æ³¨æ„å¹¶å‘é™åˆ¶æˆ–æ¥å—é•¿æ—¶é—´è¿è¡Œã€‚
                          # å¦‚æœä¸»æœºè¿‡å¤šï¼Œå¯èƒ½éœ€è¦å¹¶è¡Œ `strategy: matrix`ï¼Œä½† matrix éš¾ä»¥ä¸ŠæŠ¥ CSV æ±‡æ€»ã€‚
                          # è¿™é‡Œæš‚æ—¶ç»´æŒä¸²è¡Œå¾ªç¯ï¼Œå‡è®¾ä¸»æœºæ•°åœ¨å¯æ§èŒƒå›´å†… (10-15å° ~ 75åˆ†)ã€‚
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install cloudflared
        run: |
          sudo cp bin/cloudflared /usr/local/bin/cloudflared
          cloudflared --version

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << 'EOF'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          sudo apt-get update -qq && sudo apt-get install -y -qq sshpass jq bc

      - name: Run Monitor Loop
        id: monitor
        env:
          HOSTS_CONFIG: ${{ secrets.HOSTS_CONFIG }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          TARGET_HOST_INPUT: ${{ github.event.inputs.target_host }}
        run: |
          SSH_OPTS="-o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -o ServerAliveInterval=30"
          
          # CSV æ–‡ä»¶
          mkdir -p csv
          CSV_FILE="csv/resource_usage.csv"
          echo "name,cpu_usage_pct,mem_usage_pct,timestamp" > "$CSV_FILE"
          
          # è·å–ä¸»æœºåˆ—è¡¨
          HOST_COUNT=$(echo "$HOSTS_CONFIG" | jq '. | length')
          echo "Total hosts: $HOST_COUNT"
          
          for INDEX in $(seq 0 $((HOST_COUNT - 1))); do
            host_item=$(echo "$HOSTS_CONFIG" | jq -c ".[$INDEX]")
            HOST_NAME=$(echo "$host_item" | jq -r '.name')
            SSH_HOST=$(echo "$host_item" | jq -r '.ssh_host')
            CPU_TYPE=$(echo "$host_item" | jq -r '.cpu_type')
            
            if [ "$HOST_NAME" = "null" ] || [ -z "$HOST_NAME" ]; then continue; fi
            if [ "$CPU_TYPE" != "arm64" ]; then continue; fi
            
            if [ -n "$TARGET_HOST_INPUT" ] && [ "$HOST_NAME" != "$TARGET_HOST_INPUT" ]; then
                continue
            fi
            
            echo ""
            echo "==========================================="
            echo "Processing: $HOST_NAME"
            echo "==========================================="
            
            # å»ºç«‹ Tunnel
            pkill -f "cloudflared.*2222" 2>/dev/null || true
            sleep 2
            cloudflared access ssh --hostname "$SSH_HOST" --url "ssh://127.0.0.1:2222" &
            TUNNEL_PID=$!
            sleep 5
            
            if ! kill -0 $TUNNEL_PID 2>/dev/null; then
              echo "âŒ Tunnel è¿æ¥å¤±è´¥"
              continue
            fi
            
            # æ‰§è¡Œç›‘æ§è„šæœ¬ (5åˆ†é’Ÿ)
            # é€»è¾‘ï¼šæ¯ 10 ç§’é‡‡é›†ä¸€æ¬¡ï¼Œå…± 30 æ¬¡ã€‚è®¡ç®—å¹³å‡å€¼ã€‚
            # ä½¿ç”¨ /proc/stat è®¡ç®— CPU, free è®¡ç®—å†…å­˜
            echo ">>> å¼€å§‹ç›‘æ§ (5åˆ†é’Ÿ)..."
            
            STATS=$(sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -n -p 2222 "${SSH_USERNAME}@127.0.0.1" '
              CPU_SUM=0
              MEM_SUM=0
              COUNT=0
              MAX_LOOPS=30
              
              # è·å–åˆå§‹ CPU çŠ¶æ€
              read cpu user nice system idle iowait irq softirq steal guest < /proc/stat
              PREV_TOTAL=$((user+nice+system+idle+iowait+irq+softirq+steal))
              PREV_IDLE=$((idle+iowait))
              
              for i in $(seq 1 $MAX_LOOPS); do
                sleep 10
                
                # ------ CPU è®¡ç®— ------
                read cpu user nice system idle iowait irq softirq steal guest < /proc/stat
                TOTAL=$((user+nice+system+idle+iowait+irq+softirq+steal))
                IDLE=$((idle+iowait))
                
                DIFF_TOTAL=$((TOTAL-PREV_TOTAL))
                DIFF_IDLE=$((IDLE-PREV_IDLE))
                
                if [ "$DIFF_TOTAL" -eq 0 ]; then DIFF_TOTAL=1; fi
                CPU_USAGE=$((100 * (DIFF_TOTAL - DIFF_IDLE) / DIFF_TOTAL))
                
                PREV_TOTAL=$TOTAL
                PREV_IDLE=$IDLE
                
                # ------ å†…å­˜ è®¡ç®— (KB) ------
                # MemTotal: 24000000 kB
                # MemAvailable: ...
                # Use MemAvailable for accurate "free" logic, or just (Total-Available)/Total
                
                MEM_INFO=$(grep -E "MemTotal|MemAvailable" /proc/meminfo)
                TOTAL_KB=$(echo "$MEM_INFO" | grep "MemTotal" | awk "{print \$2}")
                AVAIL_KB=$(echo "$MEM_INFO" | grep "MemAvailable" | awk "{print \$2}")
                
                if [ -z "$AVAIL_KB" ]; then
                   # Fallback for old kernels without MemAvailable
                   FREE_KB=$(grep "MemFree" /proc/meminfo | awk "{print \$2}")
                   BUFF_KB=$(grep "Buffers" /proc/meminfo | awk "{print \$2}")
                   CACH_KB=$(grep "^Cached" /proc/meminfo | awk "{print \$2}")
                   AVAIL_KB=$((FREE_KB + BUFF_KB + CACH_KB))
                fi
                
                MEM_USED_KB=$((TOTAL_KB - AVAIL_KB))
                MEM_USAGE=$((100 * MEM_USED_KB / TOTAL_KB))
                
                CPU_SUM=$((CPU_SUM + CPU_USAGE))
                MEM_SUM=$((MEM_SUM + MEM_USAGE))
                COUNT=$((COUNT + 1))
              done
              
              AVG_CPU=$((CPU_SUM / COUNT))
              AVG_MEM=$((MEM_SUM / COUNT))
              
              echo "RESULT::$AVG_CPU::$AVG_MEM"
            ' 2>&1)
            
            RESULT_LINE=$(echo "$STATS" | grep "RESULT::")
            if [ -n "$RESULT_LINE" ]; then
               AVG_CPU=$(echo "$RESULT_LINE" | awk -F:: '{print $2}')
               AVG_MEM=$(echo "$RESULT_LINE" | awk -F:: '{print $3}')
               echo "âœ… ç›‘æ§å®Œæˆ: CPU=${AVG_CPU}%, MEM=${AVG_MEM}%"
               
               TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S")
               echo "${HOST_NAME},${AVG_CPU},${AVG_MEM},${TIMESTAMP}" >> "$CSV_FILE"
            else
               echo "âŒ ç›‘æ§å¤±è´¥æˆ–æ— æ•°æ®è¿”å›"
               echo "$STATS"
            fi
            
            kill $TUNNEL_PID 2>/dev/null || true
          done
          
          # æ˜¾ç¤º CSV å†…å®¹
          cat "$CSV_FILE"

      - name: Commit results
        run: |
          CSV_FILE="csv/resource_usage.csv"
          if [ -f "$CSV_FILE" ]; then
            # æ’åºï¼šæŒ‰ CPU ä½¿ç”¨ç‡ (ç¬¬2åˆ—) å‡åº (ä½¿ç”¨ç‡æœ€ä½æ’å‰é¢ -> é£é™©æœ€é«˜)
            # åŒæ—¶ä¹Ÿè€ƒè™‘å†…å­˜ (ç¬¬3åˆ—) ä½œä¸ºæ¬¡çº§æ’åº
            
            echo ">>> æ’åº CSV æ–‡ä»¶ (æŒ‰ CPU ä½¿ç”¨ç‡å‡åº)..."
            head -1 "$CSV_FILE" > /tmp/csv_header.tmp
            tail -n +2 "$CSV_FILE" | sort -t',' -k2 -n -k3 -n > /tmp/csv_body.tmp
            cat /tmp/csv_header.tmp /tmp/csv_body.tmp > "$CSV_FILE"
            rm -f /tmp/csv_header.tmp /tmp/csv_body.tmp
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git pull --rebase origin main || echo "Git pull failed"
            git add "$CSV_FILE"
            git diff --staged --quiet || git commit -m "Update resource usage stats $(date -u +%Y-%m-%d)"
            git push || echo "Nothing to push"
          fi

      - name: Send Telegram notification (Low Usage Warning)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          CSV_FILE="csv/resource_usage.csv"
          
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "âš ï¸ Telegram æœªé…ç½®"
            exit 0
          fi
          
          if [ ! -f "$CSV_FILE" ]; then
             echo "âš ï¸ æ— ç»“æœæ–‡ä»¶"
             exit 0
          fi
          
          # æå– Top 10 ä½è´Ÿè½½ (å³ CSV çš„å‰10è¡Œï¼Œå› ä¸ºå·²ç»æŒ‰å‡åºæ’äº†)
          TOP10_TEXT=$(tail -n +2 "$CSV_FILE" | head -10 | awk -F',' '{printf "%2d. %-12s CPU: %s%% | MEM: %s%%\n", NR, $1, $2, $3}')
          
          TIMESTAMP=$(date -u +'%Y-%m-%d %H:%M UTC')
          
          # è­¦å‘Šä¿¡æ¯
          FINAL_MSG=$(printf "âš ï¸ *ARM64 é—²ç½®å®ä¾‹è­¦å‘Š (Top 10)*\n\nğŸ“… %s\n\nğŸ“‰ *ä½è´Ÿè½½æ’å (CPUå‡åº)*:\n\`\`\`\n%s\n\`\`\`\n\nğŸ’¡ è¯·æ³¨æ„ç”±äºè´Ÿè½½è¿‡ä½å¯èƒ½æœ‰å›æ”¶é£é™©ï¼" "$TIMESTAMP" "$TOP10_TEXT")
          
          IFS=',' read -ra CHAT_IDS <<< "$TELEGRAM_CHAT_ID"
          for chat_id in "${CHAT_IDS[@]}"; do
            chat_id=$(echo "$chat_id" | xargs)
            if [ -n "$chat_id" ]; then
              curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                -d chat_id="${chat_id}" \
                -d parse_mode="Markdown" \
                --data-urlencode "text=${FINAL_MSG}" > /dev/null
            fi
          done
          echo "âœ… Telegram å·²å‘é€"

      - name: Summary
        run: |
          echo "## ğŸ“‰ èµ„æºç›‘æ§ç»“æœ (ARM64)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          CSV_FILE="csv/resource_usage.csv"
          if [ -f "$CSV_FILE" ]; then
             echo "| å®ä¾‹åç§° | å¹³å‡ CPU (%) | å¹³å‡ å†…å­˜ (%) |" >> $GITHUB_STEP_SUMMARY
             echo "| :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY
             # ä»…æ˜¾ç¤ºå‰ 10
             tail -n +2 "$CSV_FILE" | head -10 | awk -F',' '{printf "| %s | %s%% | %s%% |\n", $1, $2, $3}' >> $GITHUB_STEP_SUMMARY
          else
             echo "æ— æ•°æ®" >> $GITHUB_STEP_SUMMARY
          fi
