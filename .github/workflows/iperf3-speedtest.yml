name: iPerf3 Speedtest All Instances (Loop)

on:
  workflow_dispatch:
    inputs:
      test_duration:
        description: '测速时长 (秒)'
        required: false
        default: '10'
      target_hosts:
        description: '选择测速主机 (GitHub限制仅支持单选)'
        required: false
        default: 'ALL'
        type: choice
        options:
          - 'ALL'
          - '巴淡岛2'
          - '巴淡岛3'
          - '巴淡岛4'
          - '迪拜'
          - '东京1'
          - '都灵'
          - '凤凰城'
          - '凤凰城2-arm1'
          - '凤凰城2-arm2'
          - '马德里3-3'
          - '马德里3-4'
          - '首尔1'
          - '首尔2'
          - '悉尼'
          - '新加坡'
          - '新加坡3'
          - '新加坡西1'
          - '新加坡西2'
          - '新加坡西3'
          - '新加坡西4'
          - '新加坡西5'
          - '新加坡西6-arm1'
          - '新加坡西6-arm2'
          - '新加坡西7'
      speed_rank:
        description: '上期测速排名 (仅当 Target Hosts 为 ALL 时生效)'
        required: false
        default: 'ALL'
        type: choice
        options:
          - 'ALL'
          - 'TOP5'
          - 'TOP10'

jobs:
  speedtest-loop:
    name: "Speedtest Loop"
    runs-on: ubuntu-latest
    timeout-minutes: 60  # 增加超时时间，因为是串行跑所有
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install cloudflared
        run: |
          sudo cp bin/cloudflared /usr/local/bin/cloudflared
          cloudflared --version

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << 'EOF'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          sudo apt-get update -qq && sudo apt-get install -y -qq sshpass jq

      - name: Run Speedtest Loop
        id: speedtest
        env:
          HOSTS_CONFIG: ${{ secrets.HOSTS_CONFIG }}
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          IPERF_CLIENT_HOST: ${{ secrets.IPERF_CLIENT_HOST }}
          IPERF_CLIENT_USER: ${{ secrets.IPERF_CLIENT_USER }}
          IPERF_CLIENT_PASS: ${{ secrets.IPERF_CLIENT_PASS }}
          TEST_DURATION: ${{ github.event.inputs.test_duration }}
          TARGET_HOSTS: ${{ github.event.inputs.target_hosts }}
          SPEED_RANK: ${{ github.event.inputs.speed_rank }}
        run: |
          # SSH 参数
          SSH_OPTS="-o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -o ServerAliveInterval=30"
          
          # 1. 建立到家庭客户机的 Tunnel (全局持久连接, Port 2202)
          echo ">>> 正在连接家庭测速客户机 ($IPERF_CLIENT_HOST)..."
          cloudflared access ssh --hostname "$IPERF_CLIENT_HOST" --url "ssh://127.0.0.1:2202" &
          TUNNEL_HOME_PID=$!
          sleep 5
          
          if ! kill -0 $TUNNEL_HOME_PID 2>/dev/null; then
            echo "❌ 无法连接家庭客户机，任务终止"
            exit 1
          fi
          echo "✅ 家庭客户机连接成功"
          
          # 2. 确定目标主机列表 (Target Selection Logic)
          CSV_FILE="csv/iperf3_results.csv"
          TARGET_LIST=""
          
          if [ "$TARGET_HOSTS" != "ALL" ] && [ -n "$TARGET_HOSTS" ]; then
              # 用户明确指定了主机 (Priority 1)
              echo "🎯 Mode: Single Host Selection"
              TARGET_LIST="$TARGET_HOSTS"
          elif [ "$SPEED_RANK" != "ALL" ] && [ -n "$SPEED_RANK" ]; then
              # 用户选择了排名筛选 (Priority 2)
              echo "📊 Mode: Speed Rank Filter ($SPEED_RANK)"
              if [ -f "$CSV_FILE" ]; then
                  # 解析 CSV 取出 Top N 的名字
                  RANK_NUM=30
                  if [ "$SPEED_RANK" == "TOP5" ]; then RANK_NUM=5; fi
                  if [ "$SPEED_RANK" == "TOP10" ]; then RANK_NUM=10; fi
                  
                  # 逻辑: 跳过表头 -> 按第2列数值降序 -> 取前N行 -> 提取第1列名字 -> 替换换行为逗号
                  # 注意: download_speed 格式如 "12 Mbps", sort -n 可以正确处理开头的数字
                  LOG_LIST=$(tail -n +2 "$CSV_FILE" | sort -t',' -k2 -nr | head -n "$RANK_NUM")
                  TARGET_LIST=$(echo "$LOG_LIST" | cut -d',' -f1 | tr '\n' ',' | sed 's/,$//')
                  
                  echo "Found Top Hosts: $TARGET_LIST"
                  
                  if [ -z "$TARGET_LIST" ]; then
                     echo "⚠️ Warning: Could not find ranking data, falling back to ALL."
                  fi
              else
                  echo "⚠️ Warning: CSV file not found (first run?), falling back to ALL."
              fi
          fi
          
          # 3. 准备 CSV 文件 (每次覆盖)
          # 注意：必须在读取完排名后才清空文件
          mkdir -p csv
          echo "name,download_speed,upload_speed,timestamp" > "$CSV_FILE"
          
          # 4. 循环遍历主机
          # 先获取主机总数
          HOST_COUNT=$(echo "$HOSTS_CONFIG" | jq '. | length')
          MAX_INDEX=$((HOST_COUNT - 1))
          
          echo "Total hosts: $HOST_COUNT (Indices 0 to $MAX_INDEX)"
          
          for INDEX in $(seq 0 $MAX_INDEX); do
            # 获取当前主机配置
            host_item=$(echo "$HOSTS_CONFIG" | jq -c ".[$INDEX]")
            HOST_NAME=$(echo "$host_item" | jq -r '.name')
            SSH_HOST=$(echo "$host_item" | jq -r '.ssh_host')
            
            if [ "$HOST_NAME" = "null" ] || [ -z "$HOST_NAME" ]; then
               continue
            fi

            # 过滤逻辑
            if [ -n "$TARGET_LIST" ]; then
                SHOULD_RUN=0
                # 替换中文逗号
                SANITIZED_TARGETS=$(echo "$TARGET_LIST" | tr '，' ',')
                # 逗号分隔循环
                OLD_IFS="$IFS"
                IFS=','
                for KEYWORD in $SANITIZED_TARGETS; do
                    KEYWORD=$(echo "$KEYWORD" | xargs)
                    # 精确匹配名字，避免部分匹配 (因为是从 CSV 读取的完整名字)
                    if [ "$HOST_NAME" == "$KEYWORD" ]; then
                        SHOULD_RUN=1
                        echo "Target match: '$HOST_NAME'"
                        break
                    fi
                    # 兼容之前的手动输入模糊匹配
                    if [[ "$HOST_NAME" == *"$KEYWORD"* ]]; then
                        SHOULD_RUN=1
                        break
                    fi
                done
                IFS="$OLD_IFS"
                
                if [ "$SHOULD_RUN" -eq 0 ]; then
                    continue
                fi
            fi
            
            echo ""
            echo "---------------------------------------------------"
            echo "Processing Host [$INDEX]: $HOST_NAME"
            echo "---------------------------------------------------"
            
            # --- 单个主机流程开始 ---
            
            # 3.1 建立 OCI 临时隧道 (Port 2222)
            cloudflared access ssh --hostname "$SSH_HOST" --url "ssh://127.0.0.1:2222" &
            TUNNEL_OCI_PID=$!
            sleep 5
            
            if ! kill -0 $TUNNEL_OCI_PID 2>/dev/null; then
              echo "❌ OCI Tunnel 失败: $HOST_NAME"
              continue
            fi
            
            # 3.2 配置 OCI (安装 iperf3 + 获取 IP + 启动 Server)
            echo ">>> 配置 OCI..."
            
            # 尝试连接并执行命令
            # 注意: 使用 -n 或 < /dev/null 防止 ssh 读取 stdin (虽然改用了 for 循环已经避免了这个问题，但为了保险)
            PREPARE_OUTPUT=$(sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -n -p 2222 "${SSH_USERNAME}@127.0.0.1" '
              which iperf3 > /dev/null 2>&1 || (sudo apt-get update -qq && sudo apt-get install -y -qq iperf3)
              IP=$(curl -4 -s ip.sb)
              echo "PUBLIC_IP::$IP"
              sudo pkill -9 iperf3 2>/dev/null || true
              sudo iptables -I INPUT -p tcp --dport 5201 -j ACCEPT 2>/dev/null || true
              sudo netfilter-persistent save 2>/dev/null || true
              sudo nohup iperf3 -s -D > /dev/null 2>&1
              sleep 2
              pgrep -x iperf3 > /dev/null && echo "SERVER_STARTED" || echo "SERVER_FAILED"
            ' 2>&1)
            
            # 解析输出
            OCI_PUBLIC_IP=$(echo "$PREPARE_OUTPUT" | grep "PUBLIC_IP::" | cut -d':' -f3 | tr -d '\r')
            SERVER_STATUS=$(echo "$PREPARE_OUTPUT" | grep "SERVER_STARTED")
            
            if [ -z "$OCI_PUBLIC_IP" ] || [ -z "$SERVER_STATUS" ]; then
               echo "❌ OCI 配置失败 (IP: $OCI_PUBLIC_IP, Server: $SERVER_STATUS)"
               kill $TUNNEL_OCI_PID 2>/dev/null || true
               continue
            fi
            
            MASKED_IP=$(echo "$OCI_PUBLIC_IP" | awk -F. '{print $1"."$2"."$3".*"}')
            echo "✅ OCI 就绪: $MASKED_IP"
            
            # 3.3 客户机测速 (Home -> OCI)
            echo ">>> 开始测速..."
            
            UNSET_PROXY="unset http_proxy https_proxy ftp_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY"
            
            # 下载 (Server sends to Client)
            IPERF_DL_RESULT=$(sshpass -p "$IPERF_CLIENT_PASS" ssh $SSH_OPTS -n -p 2202 "${IPERF_CLIENT_USER}@127.0.0.1" "
              $UNSET_PROXY
              which iperf3 > /dev/null 2>&1 || (apt-get update -qq && apt-get install -y -qq iperf3)
              iperf3 -c $OCI_PUBLIC_IP -R -t ${TEST_DURATION:-10} -J || echo '{\"error\": \"connection failed\"}'
            ")
            
            sleep 1
            
            # 上传 (Client sends to Server)
            IPERF_UL_RESULT=$(sshpass -p "$IPERF_CLIENT_PASS" ssh $SSH_OPTS -n -p 2202 "${IPERF_CLIENT_USER}@127.0.0.1" "
              $UNSET_PROXY
              iperf3 -c $OCI_PUBLIC_IP -t ${TEST_DURATION:-10} -J || echo '{\"error\": \"connection failed\"}'
            ")
            
            # 3.4 清理 OCI
            sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -n -p 2222 "${SSH_USERNAME}@127.0.0.1" 'sudo pkill -9 iperf3 2>/dev/null || true'
            kill $TUNNEL_OCI_PID 2>/dev/null || true
            
            # 3.5 解析结果 & 写入 CSV
            get_speed_mbps() {
                local json=$1
                if echo "$json" | grep -q '"error"'; then
                    echo "N/A"
                else
                    local bits=$(echo "$json" | jq -r '.end.sum_received.bits_per_second // 0' 2>/dev/null)
                    if [ -z "$bits" ] || [ "$bits" = "0" ] || [ "$bits" = "null" ]; then
                        echo "N/A"
                    else
                        echo "scale=2; $bits / 1000000" | bc
                    fi
                fi
            }
            
            DL_VAL=$(get_speed_mbps "$IPERF_DL_RESULT")
            UL_VAL=$(get_speed_mbps "$IPERF_UL_RESULT")
            
            if [ "$DL_VAL" != "N/A" ]; then DL_STR="${DL_VAL} Mbps"; else DL_STR="N/A"; fi
            if [ "$UL_VAL" != "N/A" ]; then UL_STR="${UL_VAL} Mbps"; else UL_STR="N/A"; fi
            
            TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S")
            
            # 写入文件
            echo "${HOST_NAME},${DL_STR},${UL_STR},${TIMESTAMP}" >> "$CSV_FILE"
            echo "✅ 结果: 下载 $DL_STR | 上传 $UL_STR"
            
            # --- 单个主机流程结束 ---
            
          done
          
          # 结束后清理家庭隧道
          kill $TUNNEL_HOME_PID 2>/dev/null || true
          echo "✅ 所有任务完成"
          
          # 显示当前文件内容用于调试
          echo "=== Final CSV Content ==="
          tail -20 "$CSV_FILE"

      - name: Commit results
        run: |
          CSV_FILE="csv/iperf3_results.csv"
          if [ -f "$CSV_FILE" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git pull --rebase origin main || echo "Git pull failed"
            git add "$CSV_FILE"
            git diff --staged --quiet || git commit -m "Update iPerf3 speedtest results (Loop) $(date -u +%Y-%m-%d)"
            git push || echo "Nothing to push"
          fi

      - name: Summary
        run: |
          CSV_FILE="csv/iperf3_results.csv"
          TODAY=$(date -u +"%Y-%m-%d")
          
          echo "## 🚀 iPerf3 测速结果 (Single Loop)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 🏆 速度排名 (Top 10)" >> $GITHUB_STEP_SUMMARY
          echo "| 下载速度 | 上传速度 | 实例名称 |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "$CSV_FILE" ]; then
            grep "$TODAY" "$CSV_FILE" 2>/dev/null | grep -v "N/A" | \
              awk -F',' '{
                dl = $2; ul = $3;
                gsub(/ Mbps/, "", dl); gsub(/ Mbps/, "", ul);
                printf "| %s Mbps | %s Mbps | %s |\n", dl, ul, $1
              }' | sort -k2 -rn | head -10 >> $GITHUB_STEP_SUMMARY
          else
            echo "No results found." >> $GITHUB_STEP_SUMMARY
          fi
