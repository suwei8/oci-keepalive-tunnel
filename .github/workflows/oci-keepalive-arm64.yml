name: OCI Keepalive via Tunnel (ARM64)

on:
  schedule:
    # æ¯ 3 å°æ—¶æ‰§è¡Œä¸€æ¬¡
    - cron: "0 */3 * * *"
  workflow_dispatch:
    inputs:
      target_index:
        description: 'æŒ‡å®šä¸»æœºç´¢å¼• (0-19, ç•™ç©º=å…¨éƒ¨)'
        required: false
        default: ''

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # æ¯ä¸ªä¸»æœºä½œä¸ºç‹¬ç«‹ Job (ä½¿ç”¨ç´¢å¼•é¿å…æš´éœ²ä¸»æœºå)
  keepalive:
    name: "Host ${{ matrix.index }}"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        # ä½¿ç”¨ç´¢å¼•é¿å…åœ¨ YAML ä¸­ç¡¬ç¼–ç ä¸»æœºä¿¡æ¯ (æ”¯æŒæœ€å¤š 30 å°)
        index: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]

    steps:
      - name: Get host info from secrets
        id: host
        env:
          HOSTS_CONFIG: ${{ secrets.HOSTS_CONFIG }}
          HOST_INDEX: ${{ matrix.index }}
          TARGET_INDEX: ${{ github.event.inputs.target_index }}
        run: |
          # å¦‚æžœæŒ‡å®šäº†ç›®æ ‡ç´¢å¼•ä¸”ä¸åŒ¹é…ï¼Œè·³è¿‡
          if [ -n "$TARGET_INDEX" ] && [ "$TARGET_INDEX" != "$HOST_INDEX" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping index $HOST_INDEX (target: $TARGET_INDEX)"
            exit 0
          fi
          
          # ä»Ž secrets èŽ·å–ä¸»æœºä¿¡æ¯
          HOST_NAME=$(echo "$HOSTS_CONFIG" | jq -r ".[$HOST_INDEX].name")
          SSH_HOST=$(echo "$HOSTS_CONFIG" | jq -r ".[$HOST_INDEX].ssh_host")
          CPU_TYPE=$(echo "$HOSTS_CONFIG" | jq -r ".[$HOST_INDEX].cpu_type")
          
          if [ "$HOST_NAME" = "null" ] || [ -z "$HOST_NAME" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "No host at index $HOST_INDEX"
            exit 0
          fi
          
          # åªå¤„ç† arm64 ç±»åž‹çš„ä¸»æœº
          if [ "$CPU_TYPE" != "arm64" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping non-arm64 host at index $HOST_INDEX"
            exit 0
          fi
          
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "name=$HOST_NAME" >> $GITHUB_OUTPUT
          echo "::add-mask::$SSH_HOST"
          echo "ssh_host=$SSH_HOST" >> $GITHUB_OUTPUT
          echo "Host: $HOST_NAME ($SSH_HOST)"

      - name: Checkout repository
        if: steps.host.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Install cloudflared
        if: steps.host.outputs.skip != 'true'
        run: |
          sudo mkdir -p /usr/local/bin
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /usr/local/bin/cloudflared
          sudo chmod +x /usr/local/bin/cloudflared
          cloudflared --version

      - name: Setup SSH
        if: steps.host.outputs.skip != 'true'
        run: |
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << 'EOF'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          sudo apt-get update -qq && sudo apt-get install -y -qq sshpass

      - name: Whitelist GitHub Actions IP
        if: steps.host.outputs.skip != 'true'
        env:
          SSH_HOST: ${{ steps.host.outputs.ssh_host }}
          CF_API_EMAIL: ${{ secrets.CF_API_EMAIL }}
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          CF_ZONE_ID: ${{ secrets.CF_ZONE_ID }}
          CF_API_EMAIL_555606: ${{ secrets.CF_API_EMAIL_555606 }}
          CF_API_KEY_555606: ${{ secrets.CF_API_KEY_555606 }}
          CF_ZONE_ID_555606: ${{ secrets.CF_ZONE_ID_555606 }}
        run: |
          echo "=========================================="
          echo "Whitelisting GitHub Actions IPs"
          echo "=========================================="
          
          # Extract domain from SSH_HOST
          DOMAIN=$(echo "$SSH_HOST" | awk -F'.' '{print $(NF-1)"."$NF}')
          echo "Domain: $DOMAIN"
          
          # Select Cloudflare credentials based on domain
          if [[ "$DOMAIN" == "555606.xyz" ]]; then
            API_EMAIL="$CF_API_EMAIL_555606"
            API_KEY="$CF_API_KEY_555606"
            ZONE_ID="$CF_ZONE_ID_555606"
          elif [[ "$DOMAIN" == "ynshanghui.com" ]]; then
            API_EMAIL="$CF_API_EMAIL"
            API_KEY="$CF_API_KEY"
            ZONE_ID="$CF_ZONE_ID"
          else
            echo "âŒ Unknown domain: $DOMAIN"
            exit 1
          fi
          
          echo "Using Cloudflare Zone: $ZONE_ID"
          
          # Get current GitHub Actions Runner IP
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "GitHub Actions Runner IP: $RUNNER_IP"
          
          # Check if current Runner IP is already whitelisted
          echo "Checking if current Runner IP is whitelisted..."
          EXISTING_RULES=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/firewall/access_rules/rules" \
            -H "X-Auth-Email: $API_EMAIL" \
            -H "X-Auth-Key: $API_KEY" \
            -H "Content-Type: application/json")
          
          RUNNER_WHITELISTED=false
          
          # Check if Runner IP is in any existing IP range rules
          for rule in $(echo "$EXISTING_RULES" | jq -r '.result[] | select(.mode == "whitelist") | .configuration.value'); do
            # Check if it's an IP range and if our IP falls within it
            if echo "$rule" | grep -q "/"; then
              # For CIDR ranges, we'd need to check if IP is in range (complex)
              # For simplicity, just check if the IP matches exactly
              if [[ "$rule" == "$RUNNER_IP" ]]; then
                RUNNER_WHITELISTED=true
                break
              fi
            else
              # Exact IP match
              if [[ "$rule" == "$RUNNER_IP" ]]; then
                RUNNER_WHITELISTED=true
                break
              fi
            fi
          done
          
          if [ "$RUNNER_WHITELISTED" = "true" ]; then
            echo "âœ… Current Runner IP is already whitelisted"
          else
            echo "âš ï¸  Current Runner IP NOT in whitelist, adding now..."
            
            # Add current Runner IP specifically
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/firewall/access_rules/rules" \
              -H "X-Auth-Email: $API_EMAIL" \
              -H "X-Auth-Key: $API_KEY" \
              -H "Content-Type: application/json" \
              --data '{"mode":"whitelist","configuration":{"target":"ip","value":"'$RUNNER_IP'"},"notes":"GitHub Actions Runner IP (Auto)"}')
            
            SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
            if [ "$SUCCESS" = "true" ]; then
              echo "âœ… Successfully whitelisted current Runner IP: $RUNNER_IP"
            else
              ERROR_MSG=$(echo "$RESPONSE" | jq -r '.errors[0].message')
              echo "âŒ Failed to whitelist Runner IP: $ERROR_MSG"
              
              # If already exists error (code 81053), that's actually OK
              ERROR_CODE=$(echo "$RESPONSE" | jq -r '.errors[0].code')
              if [ "$ERROR_CODE" = "81053" ]; then
                echo "âœ… IP already whitelisted (duplicate rule)"
              else
                echo "âš ï¸  Continuing anyway, but connection may fail..."
              fi
            fi
            
            # Wait for rule to propagate
            echo "â³ Waiting 3 seconds for firewall rule to propagate..."
            sleep 3
          fi
          
          # Optionally also whitelist GitHub Actions IP ranges for future runs
          echo ""
          echo "Adding GitHub Actions IP ranges for future runs..."
          GITHUB_IPS=$(curl -s https://api.github.com/meta | jq -r '.actions[]' | head -10)
          
          RANGE_COUNT=0
          for IP_RANGE in $GITHUB_IPS; do
            # Check if this range is already whitelisted
            ALREADY_EXISTS=$(echo "$EXISTING_RULES" | jq -r '.result[] | select(.configuration.value == "'$IP_RANGE'") | .id')
            
            if [ -n "$ALREADY_EXISTS" ]; then
              continue
            fi
            
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/firewall/access_rules/rules" \
              -H "X-Auth-Email: $API_EMAIL" \
              -H "X-Auth-Key: $API_KEY" \
              -H "Content-Type: application/json" \
              --data '{"mode":"whitelist","configuration":{"target":"ip_range","value":"'$IP_RANGE'"},"notes":"GitHub Actions IP Range (Auto)"}')
            
            SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
            if [ "$SUCCESS" = "true" ]; then
              echo "  âœ… Whitelisted range: $IP_RANGE"
              RANGE_COUNT=$((RANGE_COUNT + 1))
            fi
            
            # Limit to 5 ranges per run to avoid rate limits
            if [ $RANGE_COUNT -ge 5 ]; then
              break
            fi
            
            sleep 0.5
          done
          
          if [ $RANGE_COUNT -gt 0 ]; then
            echo "âœ… Added $RANGE_COUNT new IP ranges"
          else
            echo "âœ… All IP ranges already whitelisted"
          fi
          
          echo ""
          echo "âœ… IP whitelisting complete - ready to connect"

      - name: Run keepalive
        if: steps.host.outputs.skip != 'true'
        env:
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          HOST_NAME: ${{ steps.host.outputs.name }}
          SSH_HOST: ${{ steps.host.outputs.ssh_host }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          SECURITY_KEYWORDS: ${{ secrets.SECURITY_KEYWORDS }}
        run: |
          echo "=========================================="
          echo "Starting keepalive for: $HOST_NAME"
          echo "=========================================="
          
          SSH_OPTS="-o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -o ServerAliveInterval=60 -o ServerAliveCountMax=3"
          MAX_RETRIES=3
          
          
          
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo ""
            echo ">>> å°è¯• $attempt / $MAX_RETRIES"
            
            # é¦–æ¬¡å¤±è´¥åŽç­‰å¾…5ç§’
            if [ $attempt -gt 1 ]; then
              echo "â³ Waiting 5 seconds before retry (Cloudflare rate limit protection)..."
              sleep 5
            fi
            
            # æ¸…ç†ä¹‹å‰çš„éš§é“
            pkill -f "cloudflared access ssh" 2>/dev/null || true
            sleep 1
            
            # å¯åŠ¨ Cloudflare Tunnel
            cloudflared access ssh --hostname "$SSH_HOST" --url "ssh://127.0.0.1:2222" &
            TUNNEL_PID=$!
            
            # ç­‰å¾… Cloudflare Tunnel å»ºç«‹è¿žæŽ¥
            echo "Waiting for tunnel to initialize..."
            sleep 15
            
            # æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«ç›‘å¬ (ç®€å•æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜æ´»ç€æ˜¯ä¸å¤Ÿçš„)
            if ! kill -0 $TUNNEL_PID 2>/dev/null; then
              echo "âŒ Tunnel failed to start (attempt $attempt)"
              if [ $attempt -eq $MAX_RETRIES ]; then
                echo "âŒ All retries failed - Tunnel"
                exit 1
              fi
              sleep 5
              continue
            fi
            echo "âœ… Tunnel established"
            
            # åŒæ­¥ä»“åº“
            if ! sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -p 2222 "${SSH_USERNAME}@127.0.0.1" '
              REPO_DIR="$HOME/oci-keepalive"
              REPO_URL="https://github.com/suwei8/oci-keepalive-tunnel.git"
              if [ -d "$REPO_DIR/.git" ]; then
                cd "$REPO_DIR" && git pull --quiet 2>/dev/null || (git fetch --all && git reset --hard origin/main)
              else
                rm -rf "$REPO_DIR"
                git clone --depth 1 "$REPO_URL" "$REPO_DIR"
              fi
            '; then
              echo "âŒ Failed to sync repository (attempt $attempt)"
              kill $TUNNEL_PID 2>/dev/null || true
              if [ $attempt -eq $MAX_RETRIES ]; then
                echo "âŒ All retries failed - Sync"
                exit 1
              fi
              sleep 5
              continue
            fi
            echo "âœ… Repository synced"
            
            # ðŸ›¡ï¸ å®‰å…¨æ£€æŸ¥ä¸Žæ¸…ç† (Security Check & Remediation)
            echo "ðŸ›¡ï¸ Running Security Scan..."
            if ! sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -p 2222 "${SSH_USERNAME}@127.0.0.1" '
               # 1. Kill malicious processes
               MALWARE_PIDS=$(pgrep -f "uhavenobotsxd|\.monitor")
               if [ -n "$MALWARE_PIDS" ]; then
                   echo "âš ï¸ [SECURITY] Found malware processes ($MALWARE_PIDS). Killing..."
                   kill -9 $MALWARE_PIDS 2>/dev/null || true
               fi

               # 2. Remove malicious files
               FILES_TO_REMOVE="/home/${USER}/.monitor /app/.monitor /tmp/arm*.uhavenobotsxd /tmp/x86*.uhavenobotsxd /root/arm7.uhavenobotsxd /etc/ld.so.preload"
               for f in $FILES_TO_REMOVE; do
                   if [ -f "$f" ]; then
                       echo "âš ï¸ [SECURITY] Found malicious file: $f. Removing..."
                       if [ -w "$f" ]; then
                           rm -f "$f"
                       else
                           echo "   (Need root to remove $f, try manual cleanup)"
                       fi
                   fi
               done

               # 3. Check Crontab for suspicious entries
               if crontab -l 2>/dev/null | grep -q "uhavenobotsxd"; then
                  echo "âš ï¸ [SECURITY] Malware found in crontab. Cleaning..."
                  crontab -l | grep -v "uhavenobotsxd" | crontab -
               fi
            '; then
                echo "âš ï¸ Security scan encountered minor error (non-fatal)"
            fi
            echo "âœ… Security scan completed"
            
            # æ‰§è¡Œä¿æ´»è„šæœ¬ (ä¼ é€’ Telegram å’Œå®‰å…¨é…ç½®)
            if timeout 720 sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -p 2222 "${SSH_USERNAME}@127.0.0.1" \
              "export TELEGRAM_BOT_TOKEN='$TELEGRAM_BOT_TOKEN' TELEGRAM_CHAT_ID='$TELEGRAM_CHAT_ID' SECURITY_KEYWORDS='$SECURITY_KEYWORDS' && cd \$HOME/oci-keepalive && python3 scripts/remote_keepalive.py --hostname '$HOST_NAME'"; then
              echo "âœ… Keepalive completed successfully"
              
              # å›žä¼ é¢„æµ‹ç»“æžœ
              mkdir -p predictions
              SAFE_NAME=$(echo "$HOST_NAME" | tr ' ' '_')
              sshpass -p "$SSH_PASSWORD" scp $SSH_OPTS -P 2222 \
                "${SSH_USERNAME}@127.0.0.1:/tmp/prediction_result.json" \
                "predictions/${SAFE_NAME}.json" 2>/dev/null || echo "No prediction file"
              
              kill $TUNNEL_PID 2>/dev/null || true
              
              # å®žä¾‹é—´éšæœºå»¶è¿Ÿ (5-8åˆ†é’Ÿï¼Œé¿å…è§¦å‘ DDoS ä¿æŠ¤)
              DELAY=$((300 + RANDOM % 181))  # 300-480 seconds
              echo ""
              echo "â³ Instance completed. Waiting $DELAY seconds before next instance..."
              echo "   (This delay prevents Cloudflare DDoS detection)"
              sleep $DELAY
              
              echo "âœ… Done"
              exit 0
            else
              echo "âŒ Keepalive script failed (attempt $attempt)"
              kill $TUNNEL_PID 2>/dev/null || true
              if [ $attempt -eq $MAX_RETRIES ]; then
                echo "âŒ All retries failed - Keepalive"
                exit 1
              fi
              sleep 10
              continue
            fi
          done

      - name: Upload prediction artifact
        if: success() && steps.host.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: prediction-${{ matrix.index }}
          path: predictions/*.json
          if-no-files-found: ignore
          retention-days: 1

  # æ”¶é›†æ‰€æœ‰é¢„æµ‹ç»“æžœ
  collect:
    name: Collect Predictions
    needs: keepalive
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all prediction artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: prediction-*
        continue-on-error: true

      - name: Merge predictions to CSV
        run: |
          CSV_FILE="predictions/predictions.csv"
          mkdir -p predictions
          
          if [ ! -f "$CSV_FILE" ]; then
            echo "timestamp,hostname,issue,d1,d2,d3,model_type" > "$CSV_FILE"
          fi
          
          if [ -d artifacts ]; then
            find artifacts -name "*.json" -type f | while read json_file; do
              if [ -f "$json_file" ]; then
                timestamp=$(jq -r '.timestamp' "$json_file")
                hostname=$(jq -r '.hostname' "$json_file")
                issue=$(jq -r '.issue' "$json_file")
                d1=$(jq -r '.d1' "$json_file")
                d2=$(jq -r '.d2' "$json_file")
                d3=$(jq -r '.d3' "$json_file")
                model_type=$(jq -r '.model_type' "$json_file")
                echo "${timestamp},${hostname},${issue},${d1},${d2},${d3},${model_type}" >> "$CSV_FILE"
                echo "Added: $hostname -> $d1 $d2 $d3"
              fi
            done
          fi
          
          if [ -f "$CSV_FILE" ] && [ $(wc -l < "$CSV_FILE") -gt 1 ]; then
            head -1 "$CSV_FILE" > /tmp/csv_header.tmp
            tail -n +2 "$CSV_FILE" | sort -t',' -k1 -r > /tmp/csv_body.tmp
            cat /tmp/csv_header.tmp /tmp/csv_body.tmp > "$CSV_FILE"
            rm -f /tmp/csv_header.tmp /tmp/csv_body.tmp
          fi

      - name: Commit predictions
        run: |
          if [ -f predictions/predictions.csv ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add predictions/predictions.csv
            git diff --staged --quiet || git commit -m "Update predictions $(date -u +%Y-%m-%d)"
            git push || echo "Nothing to push"
          fi

      - name: Summary
        run: |
          echo "## Keepalive Results" >> $GITHUB_STEP_SUMMARY
          if [ -f predictions/predictions.csv ]; then
            echo '```' >> $GITHUB_STEP_SUMMARY
            head -6 predictions/predictions.csv >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
