name: OCI Keepalive via Tunnel (ARM64)

on:
  schedule:
    # 每 2 小时执行一次
    - cron: "0 */2 * * *"
  workflow_dispatch:
    inputs:
      target_index:
        description: '指定主机索引 (0-19, 留空=全部)'
        required: false
        default: ''

jobs:
  # 每个主机作为独立 Job (使用索引避免暴露主机名)
  keepalive:
    name: "Host ${{ matrix.index }}"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        # 使用索引避免在 YAML 中硬编码主机信息 (支持最多 30 台)
        index: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]

    steps:
      - name: Get host info from secrets
        id: host
        env:
          HOSTS_CONFIG: ${{ secrets.HOSTS_CONFIG }}
          HOST_INDEX: ${{ matrix.index }}
          TARGET_INDEX: ${{ github.event.inputs.target_index }}
        run: |
          # 如果指定了目标索引且不匹配，跳过
          if [ -n "$TARGET_INDEX" ] && [ "$TARGET_INDEX" != "$HOST_INDEX" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping index $HOST_INDEX (target: $TARGET_INDEX)"
            exit 0
          fi
          
          # 从 secrets 获取主机信息
          HOST_NAME=$(echo "$HOSTS_CONFIG" | jq -r ".[$HOST_INDEX].name")
          SSH_HOST=$(echo "$HOSTS_CONFIG" | jq -r ".[$HOST_INDEX].ssh_host")
          CPU_TYPE=$(echo "$HOSTS_CONFIG" | jq -r ".[$HOST_INDEX].cpu_type")
          
          if [ "$HOST_NAME" = "null" ] || [ -z "$HOST_NAME" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "No host at index $HOST_INDEX"
            exit 0
          fi
          
          # 只处理 arm64 类型的主机
          if [ "$CPU_TYPE" != "arm64" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping non-arm64 host at index $HOST_INDEX"
            exit 0
          fi
          
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "name=$HOST_NAME" >> $GITHUB_OUTPUT
          echo "ssh_host=$SSH_HOST" >> $GITHUB_OUTPUT
          echo "Host: $HOST_NAME ($SSH_HOST)"

      - name: Checkout repository
        if: steps.host.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Install cloudflared
        if: steps.host.outputs.skip != 'true'
        run: |
          sudo cp bin/cloudflared /usr/local/bin/cloudflared
          cloudflared --version

      - name: Setup SSH
        if: steps.host.outputs.skip != 'true'
        run: |
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << 'EOF'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          sudo apt-get update -qq && sudo apt-get install -y -qq sshpass

      - name: Whitelist GitHub Actions IP
        if: steps.host.outputs.skip != 'true'
        env:
          SSH_HOST: ${{ steps.host.outputs.ssh_host }}
          CF_API_EMAIL: ${{ secrets.CF_API_EMAIL }}
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          CF_ZONE_ID: ${{ secrets.CF_ZONE_ID }}
          CF_API_EMAIL_555606: ${{ secrets.CF_API_EMAIL_555606 }}
          CF_API_KEY_555606: ${{ secrets.CF_API_KEY_555606 }}
          CF_ZONE_ID_555606: ${{ secrets.CF_ZONE_ID_555606 }}
        run: |
          echo "=========================================="
          echo "Whitelisting GitHub Actions IPs"
          echo "=========================================="
          
          # Extract domain from SSH_HOST
          DOMAIN=$(echo "$SSH_HOST" | awk -F'.' '{print $(NF-1)"."$NF}')
          echo "Domain: $DOMAIN"
          
          # Select Cloudflare credentials based on domain
          if [[ "$DOMAIN" == "555606.xyz" ]]; then
            API_EMAIL="$CF_API_EMAIL_555606"
            API_KEY="$CF_API_KEY_555606"
            ZONE_ID="$CF_ZONE_ID_555606"
          elif [[ "$DOMAIN" == "ynshanghui.com" ]]; then
            API_EMAIL="$CF_API_EMAIL"
            API_KEY="$CF_API_KEY"
            ZONE_ID="$CF_ZONE_ID"
          else
            echo "❌ Unknown domain: $DOMAIN"
            exit 1
          fi
          
          echo "Using Cloudflare Zone: $ZONE_ID"
          
          # Get current GitHub Actions Runner IP
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "GitHub Actions Runner IP: $RUNNER_IP"
          
          # Check if current Runner IP is already whitelisted
          echo "Checking if current Runner IP is whitelisted..."
          EXISTING_RULES=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/firewall/access_rules/rules" \
            -H "X-Auth-Email: $API_EMAIL" \
            -H "X-Auth-Key: $API_KEY" \
            -H "Content-Type: application/json")
          
          RUNNER_WHITELISTED=false
          
          # Check if Runner IP is in any existing IP range rules
          for rule in $(echo "$EXISTING_RULES" | jq -r '.result[] | select(.mode == "whitelist") | .configuration.value'); do
            # Check if it's an IP range and if our IP falls within it
            if echo "$rule" | grep -q "/"; then
              # For CIDR ranges, we'd need to check if IP is in range (complex)
              # For simplicity, just check if the IP matches exactly
              if [[ "$rule" == "$RUNNER_IP" ]]; then
                RUNNER_WHITELISTED=true
                break
              fi
            else
              # Exact IP match
              if [[ "$rule" == "$RUNNER_IP" ]]; then
                RUNNER_WHITELISTED=true
                break
              fi
            fi
          done
          
          if [ "$RUNNER_WHITELISTED" = "true" ]; then
            echo "✅ Current Runner IP is already whitelisted"
          else
            echo "⚠️  Current Runner IP NOT in whitelist, adding now..."
            
            # Add current Runner IP specifically
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/firewall/access_rules/rules" \
              -H "X-Auth-Email: $API_EMAIL" \
              -H "X-Auth-Key: $API_KEY" \
              -H "Content-Type: application/json" \
              --data '{"mode":"whitelist","configuration":{"target":"ip","value":"'$RUNNER_IP'"},"notes":"GitHub Actions Runner IP (Auto)"}')
            
            SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
            if [ "$SUCCESS" = "true" ]; then
              echo "✅ Successfully whitelisted current Runner IP: $RUNNER_IP"
            else
              ERROR_MSG=$(echo "$RESPONSE" | jq -r '.errors[0].message')
              echo "❌ Failed to whitelist Runner IP: $ERROR_MSG"
              
              # If already exists error (code 81053), that's actually OK
              ERROR_CODE=$(echo "$RESPONSE" | jq -r '.errors[0].code')
              if [ "$ERROR_CODE" = "81053" ]; then
                echo "✅ IP already whitelisted (duplicate rule)"
              else
                echo "⚠️  Continuing anyway, but connection may fail..."
              fi
            fi
            
            # Wait for rule to propagate
            echo "⏳ Waiting 3 seconds for firewall rule to propagate..."
            sleep 3
          fi
          
          # Optionally also whitelist GitHub Actions IP ranges for future runs
          echo ""
          echo "Adding GitHub Actions IP ranges for future runs..."
          GITHUB_IPS=$(curl -s https://api.github.com/meta | jq -r '.actions[]' | head -10)
          
          RANGE_COUNT=0
          for IP_RANGE in $GITHUB_IPS; do
            # Check if this range is already whitelisted
            ALREADY_EXISTS=$(echo "$EXISTING_RULES" | jq -r '.result[] | select(.configuration.value == "'$IP_RANGE'") | .id')
            
            if [ -n "$ALREADY_EXISTS" ]; then
              continue
            fi
            
            RESPONSE=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/firewall/access_rules/rules" \
              -H "X-Auth-Email: $API_EMAIL" \
              -H "X-Auth-Key: $API_KEY" \
              -H "Content-Type: application/json" \
              --data '{"mode":"whitelist","configuration":{"target":"ip_range","value":"'$IP_RANGE'"},"notes":"GitHub Actions IP Range (Auto)"}')
            
            SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
            if [ "$SUCCESS" = "true" ]; then
              echo "  ✅ Whitelisted range: $IP_RANGE"
              RANGE_COUNT=$((RANGE_COUNT + 1))
            fi
            
            # Limit to 5 ranges per run to avoid rate limits
            if [ $RANGE_COUNT -ge 5 ]; then
              break
            fi
            
            sleep 0.5
          done
          
          if [ $RANGE_COUNT -gt 0 ]; then
            echo "✅ Added $RANGE_COUNT new IP ranges"
          else
            echo "✅ All IP ranges already whitelisted"
          fi
          
          echo ""
          echo "✅ IP whitelisting complete - ready to connect"

      - name: Run keepalive
        if: steps.host.outputs.skip != 'true'
        env:
          SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          HOST_NAME: ${{ steps.host.outputs.name }}
          SSH_HOST: ${{ steps.host.outputs.ssh_host }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          SECURITY_KEYWORDS: ${{ secrets.SECURITY_KEYWORDS }}
        run: |
          echo "=========================================="
          echo "Starting keepalive for: $HOST_NAME"
          echo "=========================================="
          
          SSH_OPTS="-o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -o ServerAliveInterval=60 -o ServerAliveCountMax=3"
          MAX_RETRIES=3
          
          
          
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo ""
            echo ">>> 尝试 $attempt / $MAX_RETRIES"
            
            # 首次失败后等待5秒
            if [ $attempt -gt 1 ]; then
              echo "⏳ Waiting 5 seconds before retry (Cloudflare rate limit protection)..."
              sleep 5
            fi
            
            # 清理之前的隧道
            pkill -f "cloudflared access ssh" 2>/dev/null || true
            sleep 1
            
            # 启动 Cloudflare Tunnel
            cloudflared access ssh --hostname "$SSH_HOST" --url "ssh://127.0.0.1:2222" &
            TUNNEL_PID=$!
            sleep 5
            
            if ! kill -0 $TUNNEL_PID 2>/dev/null; then
              echo "❌ Tunnel failed to start (attempt $attempt)"
              if [ $attempt -eq $MAX_RETRIES ]; then
                echo "❌ All retries failed - Tunnel"
                exit 1
              fi
              sleep 5
              continue
            fi
            echo "✅ Tunnel established"
            
            # 同步仓库
            if ! sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -p 2222 "${SSH_USERNAME}@127.0.0.1" '
              REPO_DIR="$HOME/oci-keepalive"
              REPO_URL="https://github.com/suwei8/oci-keepalive-tunnel.git"
              if [ -d "$REPO_DIR/.git" ]; then
                cd "$REPO_DIR" && git pull --quiet 2>/dev/null || (git fetch --all && git reset --hard origin/main)
              else
                rm -rf "$REPO_DIR"
                git clone --depth 1 "$REPO_URL" "$REPO_DIR"
              fi
            '; then
              echo "❌ Failed to sync repository (attempt $attempt)"
              kill $TUNNEL_PID 2>/dev/null || true
              if [ $attempt -eq $MAX_RETRIES ]; then
                echo "❌ All retries failed - Sync"
                exit 1
              fi
              sleep 5
              continue
            fi
            echo "✅ Repository synced"
            
            # 执行保活脚本 (传递 Telegram 和安全配置)
            if timeout 720 sshpass -p "$SSH_PASSWORD" ssh $SSH_OPTS -p 2222 "${SSH_USERNAME}@127.0.0.1" \
              "export TELEGRAM_BOT_TOKEN='$TELEGRAM_BOT_TOKEN' TELEGRAM_CHAT_ID='$TELEGRAM_CHAT_ID' SECURITY_KEYWORDS='$SECURITY_KEYWORDS' && cd \$HOME/oci-keepalive && python3 scripts/remote_keepalive.py --hostname '$HOST_NAME'"; then
              echo "✅ Keepalive completed successfully"
              
              # 回传预测结果
              mkdir -p predictions
              SAFE_NAME=$(echo "$HOST_NAME" | tr ' ' '_')
              sshpass -p "$SSH_PASSWORD" scp $SSH_OPTS -P 2222 \
                "${SSH_USERNAME}@127.0.0.1:/tmp/prediction_result.json" \
                "predictions/${SAFE_NAME}.json" 2>/dev/null || echo "No prediction file"
              
              kill $TUNNEL_PID 2>/dev/null || true
              
              # 实例间随机延迟 (5-8分钟，避免触发 DDoS 保护)
              DELAY=$((300 + RANDOM % 181))  # 300-480 seconds
              echo ""
              echo "⏳ Instance completed. Waiting $DELAY seconds before next instance..."
              echo "   (This delay prevents Cloudflare DDoS detection)"
              sleep $DELAY
              
              echo "✅ Done"
              exit 0
            else
              echo "❌ Keepalive script failed (attempt $attempt)"
              kill $TUNNEL_PID 2>/dev/null || true
              if [ $attempt -eq $MAX_RETRIES ]; then
                echo "❌ All retries failed - Keepalive"
                exit 1
              fi
              sleep 10
              continue
            fi
          done

      - name: Upload prediction artifact
        if: success() && steps.host.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: prediction-${{ matrix.index }}
          path: predictions/*.json
          if-no-files-found: ignore
          retention-days: 1

  # 收集所有预测结果
  collect:
    name: Collect Predictions
    needs: keepalive
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all prediction artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: prediction-*
        continue-on-error: true

      - name: Merge predictions to CSV
        run: |
          CSV_FILE="predictions/predictions.csv"
          mkdir -p predictions
          
          if [ ! -f "$CSV_FILE" ]; then
            echo "timestamp,hostname,issue,d1,d2,d3,model_type" > "$CSV_FILE"
          fi
          
          if [ -d artifacts ]; then
            find artifacts -name "*.json" -type f | while read json_file; do
              if [ -f "$json_file" ]; then
                timestamp=$(jq -r '.timestamp' "$json_file")
                hostname=$(jq -r '.hostname' "$json_file")
                issue=$(jq -r '.issue' "$json_file")
                d1=$(jq -r '.d1' "$json_file")
                d2=$(jq -r '.d2' "$json_file")
                d3=$(jq -r '.d3' "$json_file")
                model_type=$(jq -r '.model_type' "$json_file")
                echo "${timestamp},${hostname},${issue},${d1},${d2},${d3},${model_type}" >> "$CSV_FILE"
                echo "Added: $hostname -> $d1 $d2 $d3"
              fi
            done
          fi
          
          if [ -f "$CSV_FILE" ] && [ $(wc -l < "$CSV_FILE") -gt 1 ]; then
            head -1 "$CSV_FILE" > /tmp/csv_header.tmp
            tail -n +2 "$CSV_FILE" | sort -t',' -k1 -r > /tmp/csv_body.tmp
            cat /tmp/csv_header.tmp /tmp/csv_body.tmp > "$CSV_FILE"
            rm -f /tmp/csv_header.tmp /tmp/csv_body.tmp
          fi

      - name: Commit predictions
        run: |
          if [ -f predictions/predictions.csv ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add predictions/predictions.csv
            git diff --staged --quiet || git commit -m "Update predictions $(date -u +%Y-%m-%d)"
            git push || echo "Nothing to push"
          fi

      - name: Summary
        run: |
          echo "## Keepalive Results" >> $GITHUB_STEP_SUMMARY
          if [ -f predictions/predictions.csv ]; then
            echo '```' >> $GITHUB_STEP_SUMMARY
            head -6 predictions/predictions.csv >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
